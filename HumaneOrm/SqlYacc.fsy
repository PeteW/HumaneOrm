%{
open HumaneOrm.Sql
%}   

//symbolic tokens
%token <string> ID   
%token <int> INT   
%token <float> FLOAT   

//literal keyword tokens
%token AND OR 
%token COMMA DOT
%token EQ LT LE GT GE MUL SUB DIV MOD STAR ADD POW
%token JOIN INNER LEFT RIGHT ON   
%token SELECT FROM WHERE ORDER BY TOP COUNT DISTINCT
%token LIKE NOT NULL CAST AS BETWEEN SET WITH
%token ASC DESC   
%token EOF   
%token LPAREN RPAREN LBRACKET RBRACKET

// The start token becomes a parser function in the compiled code:
%start start   
%type <HumaneOrm.Sql.SqlStatement> start   
 
%%   
 
start:  query EOF { $1 }

query:  SELECT optTopDistinct columnList   
        FROM ID   
        joinList   
        whereClause   
        orderByClause   {   
                                { 
                                    Table = $5;
                                    TopDistinct = $2;
                                    Columns = List.rev $3;   
                                    Joins = $6;   
                                    Where = $7;   
                                    OrderBy = $8 
                                }   
                            }   
optTopDistinct:
	|								{None}
	| TOP LPAREN INT RPAREN			{Some(Top($3))}
	| DISTINCT						{Some(Distinct)}

columnList: //columnList produces type Column list
    | column		{ [$1] }
    | columnList COMMA column  { $3 :: $1 }   

column: //columns produce type Column
	| value											{ Expression(Atom($1), $1) }
	| expressionChain								{ Expression($1, String("[NA]"):> Value) }
	| expressionChain AS value						{ Expression($1, $3) }
    | LPAREN query RPAREN AS value					{ Subquery($2, $5) }				

expressionChain: //expressionChains produce type ScalarExpression
	| COUNT LPAREN expressionChain RPAREN			{ Unary(Count, $3)}
	| expression									{ $1 }
	| expression op expressionChain					{ Binary($2, $1, $3) }

expression: //expressions produce type ScalarExpression 
	| value											{ Atom($1) }
	| value DOT value								{ Binary(NameScope, Atom($1), Atom($3)) }
	| LPAREN expressionChain RPAREN					{ $2 }

// join clause   
joinList:   
    |                               { [] }   
    | joinClause                    { [$1] }   
    | joinClause joinList           { $1 :: $2 }       
 
joinClause:   
    | INNER JOIN joinTable joinOnClause    { $3, Inner, $4 }   
    | LEFT JOIN joinTable joinOnClause     { $3, Left, $4 }   
    | RIGHT JOIN joinTable joinOnClause    { $3, Right, $4 }   

joinTable: //joinTables produce JoinTable
	| LPAREN query RPAREN AS ID		{Subquery($2, $5)}
	| ID							{Table($1)}

joinOnClause:   
    |                               { None }   
    | ON conditionList              { Some($2) }   
 
conditionList:   
    | value op value                    { Cond($1, $2, $3) }   
    | value op value AND conditionList  { And(Cond($1, $2, $3), $5) }   
    | value op value OR conditionList   { Or(Cond($1, $2, $3), $5) }   
 
// where clause   
whereClause:   
    |                               { None }   
    | WHERE conditionList           { Some($2) }   
 
op: EQ { Eq } | LT { Lt } | LE { Le } | GT { Gt } | GE { Ge } | ADD { Add } | SUB { Sub } | MUL { Mul } | DIV { Div } | MOD { Mod } | POW {Pow}
 
value:   
    | LBRACKET value RBRACKET   { $2 }   
    | INT						{ Int($1) }   
    | FLOAT						{ Float($1) }   
    | ID						{ String($1) }   
 
// order by clause   
 
orderByClause:   
    |                               { [] }   
    | ORDER BY orderByList          { $3 }   
 
orderByList:   
    | orderBy                       { [$1] }   
    | orderBy COMMA orderByList     { $1 :: $3 }   
 
orderBy:   
    | value                            { $1, Asc }   
    | value ASC                        { $1, Asc }   
    | value DESC                       { $1, Desc}   
 
%%